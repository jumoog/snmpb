From d7c8357feadb9039834f554983c205360b6d5e93 Mon Sep 17 00:00:00 2001
From: Martin Jolicoeur <snmpb1@gmail.com>
Date: Sun, 16 Jan 2011 08:35:21 +0000
Subject: [PATCH 06/11] Separate ports for IPv4 & IPv6

Squashed commits:
* 510407e (Modified snmp++ to allow binding trap port on both ipv4 and ipv6 for all interfaces, 2011-01-14)
* 936190e (Added set/get_notify_callback_fd() to access fd when replying to INFORMS, 2011-01-16)
---
 include/snmp_pp/notifyqueue.h |   6 ++
 include/snmp_pp/uxsnmp.h      |   8 ++
 src/notifyqueue.cpp           | 149 ++++++++++++++++++++++++++--------
 src/uxsnmp.cpp                |  28 +++++--
 4 files changed, 149 insertions(+), 42 deletions(-)

diff --git a/include/snmp_pp/notifyqueue.h b/include/snmp_pp/notifyqueue.h
index 5c93e2b..753e2f1 100644
--- a/include/snmp_pp/notifyqueue.h
+++ b/include/snmp_pp/notifyqueue.h
@@ -151,7 +151,10 @@ class DLLOPT CNotifyEventQueue: public CEvents
     int Done() { return 0; }; // we are never done
     void set_listen_port(int port) { m_listen_port = port; };
     int get_listen_port() { return m_listen_port; };
+    void set_listen_port6(int port) { m_listen_port6 = port; };
+    int get_listen_port6() { return m_listen_port6; };
     SnmpSocket get_notify_fd() const;
+    SnmpSocket get_notify_fd6() const;
 
   protected:
 
@@ -185,6 +188,9 @@ class DLLOPT CNotifyEventQueue: public CEvents
     int                  m_msgCount;
     SnmpSocket           m_notify_fd;
     int                  m_listen_port;
+    SnmpSocket           m_notify_fd6;
+    UdpAddress           m_notify_addr6;
+    int                  m_listen_port6;
     EventListHolder *my_holder;
     Snmp *m_snmpSession;
     UdpAddress m_notify_addr;
diff --git a/include/snmp_pp/uxsnmp.h b/include/snmp_pp/uxsnmp.h
index 9e57a8e..e39328a 100644
--- a/include/snmp_pp/uxsnmp.h
+++ b/include/snmp_pp/uxsnmp.h
@@ -457,11 +457,13 @@ class DLLOPT Snmp: public SnmpSynchronized
    *       otherwise the default port is used.
    */
   virtual void notify_set_listen_port(const int port);
+  virtual void notify_set_listen_port6(const int port);
 
   /**
    * Get the port that is used for listening to traps and informs.
    */
   virtual int notify_get_listen_port();
+  virtual int notify_get_listen_port6();
 
   /**
    * Register to get traps and informs.
@@ -515,6 +517,9 @@ class DLLOPT Snmp: public SnmpSynchronized
    */
   void *get_notify_callback_data() { return notifycallback_data; };
 
+  SnmpSocket get_notify_callback_fd() { return notifycallback_fd; };
+  void set_notify_callback_fd(SnmpSocket fd) { notifycallback_fd = fd; };
+
   //@}
 
   /**
@@ -534,6 +539,7 @@ class DLLOPT Snmp: public SnmpSynchronized
                             SnmpSocket fd = INVALID_SOCKET);
 
   const IpAddress &get_listen_address() const {return listen_address; };
+  const IpAddress &get_listen_address6() const {return listen_address6; };
 
 #if WITH_THREADS
   /**
@@ -659,11 +665,13 @@ protected:
 #endif
 
   IpAddress listen_address;
+  IpAddress listen_address6;
   long current_rid;                   // current rid to use
 
   // inform receive member variables
   snmp_callback  notifycallback;
   void * notifycallback_data;
+  SnmpSocket notifycallback_fd;
 
   // this member var will simulate a global var
   EventListHolder *eventListHolder;
diff --git a/src/notifyqueue.cpp b/src/notifyqueue.cpp
index e3bd727..63263e6 100644
--- a/src/notifyqueue.cpp
+++ b/src/notifyqueue.cpp
@@ -76,6 +76,7 @@ char notifyqueue_version[]="#(@) SNMP++ $Id$";
 #include "snmp_pp/snmperrs.h"
 #include "snmp_pp/pdu.h"
 #include "snmp_pp/log.h"
+#include "snmp_pp/IPv6Utility.h"
 
 #ifdef SNMP_PP_NAMESPACE
 namespace Snmp_pp {
@@ -87,6 +88,11 @@ static const char *loggerModuleName = "snmp++.notifyqueue";
 extern int receive_snmp_notification(SnmpSocket sock, Snmp &snmp_session,
                                      Pdu &pdu, SnmpTarget **target);
 
+//-----[ macros ]------------------------------------------------------
+// should be in snmp.h...
+#define SNMP_PORT 161         // standard port # for SNMP
+#define SNMP_TRAP_PORT 162    // standard port # for SNMP traps
+
 #ifdef WIN32
 #define close closesocket
 #endif
@@ -249,6 +255,8 @@ int CNotifyEvent::Callback(SnmpTarget &target, Pdu &pdu, SnmpSocket fd, int stat
     else
       reason = SNMP_CLASS_NOTIFICATION;
 
+    m_snmp->set_notify_callback_fd(fd);
+
     //------[ call into the callback function ]-------------------------
     if (m_snmp->get_notify_callback())
       (m_snmp->get_notify_callback())(
@@ -294,8 +302,8 @@ CNotifyEvent *CNotifyEventQueue::CNotifyEventQueueElt::TestId(Snmp *snmp)
 //----[ CNotifyEventQueue class ]--------------------------------------
 CNotifyEventQueue::CNotifyEventQueue(EventListHolder *holder, Snmp *session)
   : m_head(NULL,NULL,NULL), m_msgCount(0), m_notify_fd(INVALID_SOCKET),
-    m_listen_port(SNMP_PP_DEFAULT_SNMP_TRAP_PORT),
-    my_holder(holder), m_snmpSession(session)
+    m_listen_port(SNMP_TRAP_PORT), m_notify_fd6(INVALID_SOCKET),
+    m_listen_port6(SNMP_TRAP_PORT), my_holder(holder), m_snmpSession(session)
 {
 //TM: could do the trap registration setup here but seems better to
 //wait until the app actually requests trap receives by calling
@@ -318,6 +326,11 @@ SnmpSocket CNotifyEventQueue::get_notify_fd() const
   return m_notify_fd;
 }
 
+SnmpSocket CNotifyEventQueue::get_notify_fd6() const
+{
+  return m_notify_fd6;
+}
+
 int CNotifyEventQueue::AddEntry(Snmp *snmp,
                                 const OidCollection &trapids,
                                 const TargetCollection &targets)
@@ -332,15 +345,16 @@ int CNotifyEventQueue::AddEntry(Snmp *snmp,
   if (!m_msgCount)
   {
     m_notify_addr = snmp->get_listen_address();
+    m_notify_addr6 = snmp->get_listen_address6();
     m_notify_addr.set_port(m_listen_port);
+    m_notify_addr6.set_port(m_listen_port6);
 
     int status = SNMP_CLASS_SUCCESS;
 
     // This is the first request to receive notifications
     // Set up the socket for the snmp trap port (162) or the
     // specified port through set_listen_port()
-    bool is_v4_address = (m_notify_addr.get_ip_version() == Address::version_ipv4);
-    if (is_v4_address)
+    if (m_notify_addr.valid())
     {
       struct sockaddr_in mgr_addr;
 
@@ -423,13 +437,14 @@ int CNotifyEventQueue::AddEntry(Snmp *snmp,
 
       debugprintf(3, "Bind to %s for notifications, fd %d.",
                   m_notify_addr.get_printable(), m_notify_fd);
-    } // is_v4_address
-    else
+    }
+
+    // Do ipv6
+    if (m_notify_addr6.valid())
     {
-      // not is_v4_address
 #ifdef SNMP_PP_IPv6
       // open a socket to be used for the session
-      if ((m_notify_fd = socket(AF_INET6, SOCK_DGRAM,0)) < 0)
+      if ((m_notify_fd6 = socket(AF_INET6, SOCK_DGRAM,0)) < 0)
       {
 #ifdef WIN32
         int werr = WSAGetLastError();
@@ -472,16 +487,16 @@ int CNotifyEventQueue::AddEntry(Snmp *snmp,
 #endif
 
       // set up the manager socket attributes
-      struct sockaddr_in6 mgr_addr;
-      memset(&mgr_addr, 0, sizeof(mgr_addr));
+      struct sockaddr_in6 mgr_addr6;
+      memset(&mgr_addr6, 0, sizeof(mgr_addr6));
 
       unsigned int scope = 0;
 
-      OctetStr addrstr = ((IpAddress &)m_notify_addr).IpAddress::get_printable();
+      OctetStr addrstr = ((IpAddress &)m_notify_addr6).IpAddress::get_printable();
 
-      if (m_notify_addr.has_ipv6_scope())
+      if (m_notify_addr6.has_ipv6_scope())
       {
-        scope = m_notify_addr.get_scope();
+        scope = m_notify_addr6.get_scope();
 
         int y = addrstr.len() - 1;
         while ((y>0) && (addrstr[y] != '%'))
@@ -494,9 +509,9 @@ int CNotifyEventQueue::AddEntry(Snmp *snmp,
       }
 
       if (inet_pton(AF_INET6, addrstr.get_printable(),
-                    &mgr_addr.sin6_addr) < 0)
+                    &mgr_addr6.sin6_addr) < 0)
       {
-	LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
+        LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
         LOG("Notify transport: inet_pton returns (errno) (str)");
         LOG(errno);
         LOG(strerror(errno));
@@ -505,13 +520,29 @@ int CNotifyEventQueue::AddEntry(Snmp *snmp,
         return SNMP_CLASS_INVALID_ADDRESS;
       }
 
-      mgr_addr.sin6_family = AF_INET6;
-      mgr_addr.sin6_port = htons(m_notify_addr.get_port());
-      mgr_addr.sin6_scope_id = scope;
+      // If IPv4 address is enabled, bind IPv6 socket for IPv6 only
+      // (i.e. no ipv4-mapped addresses)
+#ifndef WIN32
+      int on = 0;
+      if (m_notify_addr.valid())
+        on = 1;
+
+      if (setsockopt(m_notify_fd6, IPPROTO_IPV6, IPV6_V6ONLY,
+                     (char *)&on, sizeof(on)) == -1)
+      {
+        debugprintf(0, "Error: could not set IPV6_V6ONLY option on ipv6 socket.");
+        cleanup();
+        return SNMP_CLASS_TL_FAILED;
+      }
+#endif
+
+      mgr_addr6.sin6_family = AF_INET6;
+      mgr_addr6.sin6_port = htons(m_notify_addr6.get_port());
+      mgr_addr6.sin6_scope_id = scope;
 
       // bind the socket
-      if (bind(m_notify_fd, (struct sockaddr *) &mgr_addr,
-               sizeof(mgr_addr)) < 0)
+      if (bind(m_notify_fd6, (struct sockaddr *) &mgr_addr6,
+               sizeof(mgr_addr6)) < 0)
       {
 #ifdef WIN32
         int werr = WSAGetLastError();
@@ -546,12 +577,12 @@ int CNotifyEventQueue::AddEntry(Snmp *snmp,
         }
 #endif
         debugprintf(0, "Fatal: could not bind to %s",
-                    m_notify_addr.get_printable());
+                    m_notify_addr6.get_printable());
         cleanup();
         return status;
       }
       debugprintf(3, "Bind to %s for notifications, fd %d.",
-                  m_notify_addr.get_printable(), m_notify_fd);
+                  m_notify_addr6.get_printable(), m_notify_fd6);
 #else
       debugprintf(0, "User error: Enable IPv6 and recompile snmp++.");
       cleanup();
@@ -580,6 +611,13 @@ void CNotifyEventQueue::cleanup()
     m_notify_fd = INVALID_SOCKET;
   }
   m_notify_addr.clear();
+
+  if (m_notify_fd6 != INVALID_SOCKET)
+  {
+    close(m_notify_fd6);
+    m_notify_fd6 = INVALID_SOCKET;
+  }
+  m_notify_addr6.clear();
 }
 
 CNotifyEvent *CNotifyEventQueue::GetEntry(Snmp * snmp) REENTRANT ({
@@ -620,6 +658,15 @@ void CNotifyEventQueue::DeleteEntry(Snmp *snmp)
       m_notify_fd = INVALID_SOCKET;
     }
     m_notify_addr.clear();
+
+    if (m_notify_fd6 != INVALID_SOCKET)
+    {
+      debugprintf(3, "Closing notifications port %s, fd %d.",
+                  m_notify_addr6.get_printable(), m_notify_fd6);
+      close(m_notify_fd6);
+      m_notify_fd6 = INVALID_SOCKET;
+    }
+    m_notify_addr6.clear();
   }
   unlock();
 }
@@ -627,10 +674,11 @@ void CNotifyEventQueue::DeleteEntry(Snmp *snmp)
 #ifdef HAVE_POLL_SYSCALL
 int CNotifyEventQueue::GetFdCount()
 {
+  int nfd = 0;
   SnmpSynchronize _synchronize(*this); // instead of REENTRANT()
-  if (m_notify_fd == INVALID_SOCKET)
-    return 0;
-  return 1;
+  if (m_notify_fd != INVALID_SOCKET) nfd++;
+  if (m_notify_fd6 != INVALID_SOCKET) nfd++;
+  return nfd;
 }
 
 bool CNotifyEventQueue::GetFdArray(struct pollfd *readfds,
@@ -646,6 +694,14 @@ bool CNotifyEventQueue::GetFdArray(struct pollfd *readfds,
     readfds[0].events = POLLIN;
     remaining--;
   }
+  if (m_notify_fd6 != INVALID_SOCKET)
+  {
+    if (remaining == 0)
+      return false;
+    readfds[1].fd = m_notify_fd6;
+    readfds[1].events = POLLIN;
+    remaining--;
+  }
   return true;
 }
 
@@ -656,7 +712,9 @@ int CNotifyEventQueue::HandleEvents(const struct pollfd *readfds,
 
   int status = SNMP_CLASS_SUCCESS;
 
-  if (m_notify_fd == INVALID_SOCKET)
+  if ((m_notify_fd == INVALID_SOCKET) &&
+      (m_notify_fd6 == INVALID_SOCKET)
+      )
     return status;
 
   for (int i=0; i < fds; i++)
@@ -667,11 +725,14 @@ int CNotifyEventQueue::HandleEvents(const struct pollfd *readfds,
     if ((readfds[i].revents & POLLIN) == 0)
       continue; // nothing to receive
 
-    if (readfds[i].fd != m_notify_fd)
+    if ((readfds[i].fd != m_notify_fd) &&
+        (readfds[i].fd != m_notify_fd6))
       continue; // not our socket
 
-    status = receive_snmp_notification(m_notify_fd, *m_snmpSession,
-                                       pdu, &target);
+    status = receive_snmp_notification(
+                 (readfds[i].fd == m_notify_fd ? m_notify_fd:m_notify_fd6),
+                 *m_snmpSession,
+                 pdu, &target);
 
     if ((SNMP_CLASS_SUCCESS == status) ||
         (SNMP_CLASS_TL_FAILED == status))
@@ -686,7 +747,8 @@ int CNotifyEventQueue::HandleEvents(const struct pollfd *readfds,
       while (notifyEltPtr)
       {
         notifyEltPtr->GetNotifyEvent()->Callback(*target, pdu,
-                                                 m_notify_fd, status);
+                 (readfds[i].fd == m_notify_fd ? m_notify_fd:m_notify_fd6),
+                 status);
         notifyEltPtr = notifyEltPtr->GetNext();
       } // for each snmp object
     }
@@ -710,6 +772,12 @@ void CNotifyEventQueue::GetFdSets(int &maxfds, fd_set &readfds,
     if (maxfds < SAFE_INT_CAST(m_notify_fd + 1))
       maxfds = SAFE_INT_CAST(m_notify_fd + 1);
   }
+  if (m_notify_fd6 != INVALID_SOCKET)
+  {
+    FD_SET(m_notify_fd6, &readfds);
+    if (maxfds < SAFE_INT_CAST(m_notify_fd6 + 1))
+      maxfds = SAFE_INT_CAST(m_notify_fd6 + 1);
+  }
   return;
 }
 
@@ -721,15 +789,28 @@ int CNotifyEventQueue::HandleEvents(const int /*maxfds*/,
   SnmpSynchronize _synchronize(*this); // REENTRANT
   int status = SNMP_CLASS_SUCCESS;
 
-  if (m_notify_fd == INVALID_SOCKET)
+  if ((m_notify_fd == INVALID_SOCKET) &&
+     (m_notify_fd6 == INVALID_SOCKET)
+      )
     return status;
 
   Pdu pdu;
   SnmpTarget *target = NULL;
 
   // pull the notifiaction off the socket
-  if (FD_ISSET(m_notify_fd, (fd_set*)&readfds)) {
-    status = receive_snmp_notification(m_notify_fd, *m_snmpSession,
+  if (((m_notify_fd != INVALID_SOCKET) &&
+        FD_ISSET(m_notify_fd, (fd_set*)&readfds))
+      ||
+      ((m_notify_fd6 != INVALID_SOCKET) &&
+        FD_ISSET(m_notify_fd6, (fd_set*)&readfds)))
+  {
+    int not_fd;
+    if ((m_notify_fd != INVALID_SOCKET) &&
+         (FD_ISSET(m_notify_fd, (fd_set*)&readfds)))
+        not_fd = m_notify_fd;
+    else
+        not_fd = m_notify_fd6;
+    status = receive_snmp_notification(not_fd, *m_snmpSession,
                                        pdu, &target);
 
     if ((SNMP_CLASS_SUCCESS == status) ||
@@ -748,7 +829,7 @@ int CNotifyEventQueue::HandleEvents(const int /*maxfds*/,
       while (notifyEltPtr)
       {
         notifyEltPtr->GetNotifyEvent()->Callback(*target, pdu,
-                                                 m_notify_fd, status);
+                                                 not_fd, status);
         notifyEltPtr = notifyEltPtr->GetNext();
       } // for each snmp object
     }
diff --git a/src/uxsnmp.cpp b/src/uxsnmp.cpp
index 0e06eb9..3820f1e 100644
--- a/src/uxsnmp.cpp
+++ b/src/uxsnmp.cpp
@@ -634,10 +634,10 @@ Snmp::Snmp(int &status, const unsigned short port, const bool bind_ipv6)
 
   if (bind_ipv6)
   {
-    listen_address = "::";
+    listen_address6 = "::";
 
     addresses[0] = NULL;
-    addresses[1] = &listen_address;
+    addresses[1] = &listen_address6;
 
     init(status, addresses, 0, port);
   }
@@ -662,18 +662,18 @@ Snmp::Snmp( int &status, const UdpAddress& addr)
 {
   IpAddress *addresses[2];
 
-  listen_address = addr;
-
-  if (listen_address.get_ip_version() == Address::version_ipv4)
+  if (addr.get_ip_version() == Address::version_ipv4)
   {
+    listen_address = addr;
     addresses[0] = &listen_address;
     addresses[1] = NULL;
     init(status, addresses, addr.get_port(), 0);
   }
   else
   {
+    listen_address6 = addr;
     addresses[0] = NULL;
-    addresses[1] = &listen_address;
+    addresses[1] = &listen_address6;
     init(status, addresses, 0, addr.get_port());
   }
 }
@@ -689,9 +689,9 @@ Snmp::Snmp( int &status,  const UdpAddress& addr_v4,
   IpAddress *addresses[2];
 
   listen_address = addr_v4;
-  IpAddress address_v6((IpAddress)addr_v6);
+  listen_address6 = addr_v6;
   addresses[0] = &listen_address;
-  addresses[1] = &address_v6;
+  addresses[1] = &listen_address6;
 
   init(status, addresses, addr_v4.get_port(), addr_v6.get_port());
 }
@@ -1493,6 +1493,18 @@ int Snmp::notify_get_listen_port()
   return eventListHolder->notifyEventList()->get_listen_port();
 }
 
+// Set the port for listening to traps and informs.
+void Snmp::notify_set_listen_port6(const int port)
+{
+  eventListHolder->notifyEventList()->set_listen_port6(port);
+}
+
+// Get the port that is used for listening to traps and informs.
+int Snmp::notify_get_listen_port6()
+{
+  return eventListHolder->notifyEventList()->get_listen_port6();
+}
+
 //-----------------------[ register to get traps]-------------------------
 int Snmp::notify_register(const OidCollection     &trapids,
                           const TargetCollection  &targets,
-- 
2.27.0

